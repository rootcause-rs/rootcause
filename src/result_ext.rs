use rootcause_internals::handlers;

use crate::{
    IntoReport, Report,
    into_report::IntoReportCollection,
    markers::{Local, Mutable, ObjectMarker, SendSync},
};

mod sealed {
    pub trait Sealed {}
    impl<A, E> Sealed for Result<A, E> {}
}

/// Extension trait for `Result` that provides error handling and reporting functionality.
///
/// This trait adds methods to `Result` types that allow converting errors into [`Report`]s
/// with additional context and attachments. It provides both thread-safe (Send + Sync) and
/// local-only variants of each method.
pub trait ResultExt<V, E>: sealed::Sealed {
    /// Converts the error into a [`Report`].
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is `Err`,
    /// converts the error into a [`Report`].
    ///
    /// See also [`local_into_report`](ResultExt::local_into_report) for a non-thread-safe version that works with objects that are not
    /// `Send` and `Sync`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #[derive(Debug)]
    /// # struct SomeError;
    /// # impl std::fmt::Display for SomeError {
    /// #     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    /// #         todo!()
    /// #     }
    /// # }
    /// # impl std::error::Error for SomeError {}
    /// # impl SomeError { fn new(s: &str) -> Self { Self } }
    /// use rootcause::prelude::*;
    ///
    /// let result: Result<i32, SomeError> = Err(SomeError::new("something went wrong"));
    /// let report_result: Result<i32, Report<SomeError>> = result.into_report();
    /// ```
    #[track_caller]
    fn into_report(self) -> Result<V, Report<E::Context, E::Ownership, SendSync>>
    where
        E: IntoReport<SendSync>;

    /// Converts the error into a new [`Report`] using the provided context. The current error is set
    /// as a child of the new [`Report`].
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is `Err`,
    /// converts the error into a report collection and adds the provided context.
    /// The context becomes the primary error message, with the original error
    /// becoming part of the error chain.
    ///
    /// This method also works when the original error is a [`ReportCollection`], in which case all
    /// errors in that collection are set as children of the new [`Report`].
    ///
    /// See also [`local_context`](ResultExt::local_context) for a non-thread-safe version that works with objects that are not
    /// `Send` and `Sync`.
    ///
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// # type NetworkError = std::io::Error;
    /// # fn fetch_data(path: &str) -> Result<Vec<u8>, NetworkError> { Ok(Vec::new()) }
    /// use rootcause::prelude::*;
    ///
    /// let result: Result<Vec<u8>, NetworkError> = fetch_data("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<&str>> = result.context("Failed to fetch user data");
    /// ```
    #[track_caller]
    fn context<C>(self, context: C) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        C: ObjectMarker + Send + Sync + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a new [`Report`] using context generated by the provided closure.
    /// The current error is set as a child of the new [`Report`].
    ///
    /// This is similar to [`context`](ResultExt::context), but the context is computed lazily using
    /// a closure. This can be useful when computing the context is expensive, as the
    /// closure will only be called if an error actually occurs.
    ///
    /// This method also works when the original error is a [`ReportCollection`], in which case all
    /// errors in that collection are set as children of the new [`Report`].
    ///
    /// See also [`local_context_with`](ResultExt::local_context_with) for a non-thread-safe version that works with objects that are not
    /// `Send` and `Sync`.
    ///
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// use rootcause::prelude::*;
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<String>> =
    ///     result.context_with(|| format!("Failed at {}", "12:34:56"));
    /// ```
    #[track_caller]
    fn context_with<C, F>(self, context: F) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        F: FnOnce() -> C,
        C: ObjectMarker + Send + Sync + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a new [`Report`] using the provided context.
    /// The current error is set as a child of the new [`Report`].
    ///
    /// This is similar to [`context`](ResultExt::context), but uses a custom [`ContextHandler`] to control
    /// how the context is formatted and displayed.
    ///
    /// This method also works when the original error is a [`ReportCollection`], in which case all
    /// errors in that collection are set as children of the new [`Report`].
    ///
    /// See also [`local_context_custom`](ResultExt::local_context_custom) for a non-thread-safe version that works with objects that are not
    /// `Send` and `Sync`.
    ///
    /// [`ContextHandler`]: handlers::ContextHandler
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// enum ErrorContext {
    ///     DeserializationError,
    ///     IoError,
    /// }
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<ErrorContext>> =
    ///     result.context_custom::<handlers::Debug, _>(ErrorContext::IoError);
    /// ```
    #[track_caller]
    fn context_custom<H, C>(self, context: C) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        C: ObjectMarker + Send + Sync,
        H: handlers::ContextHandler<C>;

    /// Converts the error into a new [`Report`] using context generated by the provided closure.
    /// The current error is set as a child of the new [`Report`].
    ///
    /// Combines the lazy evaluation of [`context_with`](ResultExt::context_with) with the custom
    /// handler capabilities of [`context_custom`](ResultExt::context_custom).
    ///
    /// This method also works when the original error is a [`ReportCollection`], in which case all
    /// errors in that collection are set as children of the new [`Report`].
    ///
    /// See also [`local_context_custom_with`](ResultExt::local_context_custom_with) for a non-thread-safe version that works with objects that are not
    /// `Send` and `Sync`.
    ///
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// # fn expensive_computation() -> ErrorContext { ErrorContext {} }
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// struct ErrorContext {
    ///     // ...
    /// }
    ///
    /// impl ErrorContext {
    ///     pub fn new() -> Self {
    ///         expensive_computation()
    ///     }
    /// }
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<ErrorContext>> =
    ///     result.context_custom_with::<handlers::Debug, _, _>(|| ErrorContext::new());
    /// ```
    #[track_caller]
    fn context_custom_with<H, C, F>(self, context: F) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        F: FnOnce() -> C,
        C: ObjectMarker + Send + Sync,
        H: handlers::ContextHandler<C>;

    /// Converts the error into a [`Report`] and adds the provided attachment to the [`Report`].
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is `Err`,
    /// converts the error into a [`Report`] and attaches the provided data as an attachment.
    /// Attachments provide additional context without changing the primary error message.
    ///
    /// See also [`local_attach`](ResultExt::local_attach) for a non-thread-safe version that works with objects that are not
    /// `Send` and `Sync`.
    ///
    /// # Examples
    ///
    /// ```
    /// use rootcause::prelude::*;
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<std::io::Error>> =
    ///     result.attach("input: invalid_data");
    /// ```
    #[track_caller]
    fn attach<A>(self, attachment: A) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        A: ObjectMarker + Send + Sync + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a [`Report`] and adds an attachment generated by the provided closure to the [`Report`].
    ///
    /// This is similar to [`attach`](ResultExt::attach), but the attachment is computed lazily using
    /// a closure. This can be useful when computing the attachment is expensive, as the
    /// closure will only be called if an error actually occurs.
    ///
    /// See also [`local_attach_with`](ResultExt::local_attach_with) for a non-thread-safe version that works with objects that are not
    /// `Send` and `Sync`.
    ///
    /// # Examples
    ///
    /// ```
    /// use rootcause::prelude::*;
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<std::io::Error>> =
    ///     result.attach_with(|| format!("debug info: {}", "complex computation"));
    /// ```
    #[track_caller]
    fn attach_with<A, F>(self, attachment: F) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: ObjectMarker + Send + Sync + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a [`Report`] and adds the provided attachment to the [`Report`].
    ///
    /// This is similar to [`attach`](ResultExt::attach), but uses a custom [`AttachmentHandler`] to control
    /// how the attachment is formatted and displayed.
    ///
    /// See also [`local_attach_custom`](ResultExt::local_attach_custom) for a non-thread-safe version that works with objects that are not
    /// `Send` and `Sync`.
    ///
    /// [`AttachmentHandler`]: handlers::AttachmentHandler
    ///
    /// # Examples
    ///
    /// ```
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// struct MyAttachment {
    ///     // ...
    /// }
    /// # impl MyAttachment {
    /// #     fn new() -> Self { MyAttachment {} }
    /// # }
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<std::io::Error>> =
    ///     result.attach_custom::<handlers::Debug, _>(MyAttachment::new());
    /// ```
    #[track_caller]
    fn attach_custom<H, A>(self, attachment: A) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        A: ObjectMarker + Send + Sync,
        H: handlers::AttachmentHandler<A>;

    /// Converts the error into a [`Report`] and adds an attachment generated by the provided closure to the [`Report`].
    ///
    /// Combines the lazy evaluation of [`attach_with`](ResultExt::attach_with) with the custom
    /// handler capabilities of [`attach_custom`](ResultExt::attach_custom).
    ///
    /// See also [`local_attach_custom_with`](ResultExt::local_attach_custom_with) for a non-thread-safe version that works with objects that are not
    /// `Send` and `Sync`.
    ///
    /// # Examples
    ///
    /// ```
    /// # fn expensive_computation() -> MyAttachment { MyAttachment {} }
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// struct MyAttachment {
    ///     // ...
    /// }
    ///
    /// impl MyAttachment {
    ///     pub fn new() -> Self {
    ///         expensive_computation()
    ///     }
    /// }
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<std::io::Error>> =
    ///     result.attach_custom_with::<handlers::Debug, _, _>(|| MyAttachment::new());
    /// ```
    #[track_caller]
    fn attach_custom_with<H, A, F>(
        self,
        attachment: F,
    ) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: ObjectMarker + Send + Sync,
        H: handlers::AttachmentHandler<A>;

    /// Converts the error into a local (non-thread-safe) [`Report`].
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is `Err`,
    /// converts the error into a [`Report`].
    ///
    /// See also [`into_report`](ResultExt::into_report) for a thread-safe version that returns a [`Report`]
    /// that can be sent across thread boundaries.
    ///
    /// # Examples
    ///
    /// ```
    /// # fn some_function() -> Result<String, MyError> { Ok(String::new()) }
    /// use std::{fmt, rc::Rc};
    ///
    /// use rootcause::prelude::*;
    ///
    /// // This error is neither Send nor Sync
    /// #[derive(Debug)]
    /// struct MyError(Rc<String>);
    /// impl fmt::Display for MyError {
    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    ///         write!(f, "{}", self.0)
    ///     }
    /// }
    ///
    /// impl std::error::Error for MyError {}
    ///
    /// let result: Result<String, MyError> = some_function();
    /// let report_result: Result<String, Report<MyError, _, markers::Local>> =
    ///     result.local_into_report();
    /// ```
    #[track_caller]
    fn local_into_report(self) -> Result<V, Report<E::Context, E::Ownership, Local>>
    where
        E: IntoReport<Local>;

    /// Converts the error into a new local (non-thread-safe) [`Report`] using the provided context.
    /// The current error is set as a child of the new [`Report`].
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is `Err`,
    /// converts the error into a report collection and adds the provided context.
    /// The context becomes the primary error message, with the original error
    /// becoming part of the error chain.
    ///
    /// This method also works when the original error is a [`ReportCollection`], in which case all
    /// errors in that collection are set as children of the new [`Report`].
    ///
    /// See also [`context`](ResultExt::context) for a thread-safe version that returns a [`Report`]
    /// that can be sent across thread boundaries.
    ///
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// # type NetworkError = std::io::Error;
    /// # fn fetch_data(path: &str) -> Result<Vec<u8>, NetworkError> { Ok(Vec::new()) }
    /// use std::rc::Rc;
    ///
    /// use rootcause::prelude::*;
    ///
    /// let result: Result<Vec<u8>, NetworkError> = fetch_data("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<Rc<&str>, _, markers::Local>> =
    ///     result.local_context(Rc::from("This context is thread-local context"));
    /// ```
    #[track_caller]
    fn local_context<C>(self, context: C) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        C: ObjectMarker + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a new local (non-thread-safe) [`Report`] using context generated by the provided closure.
    /// The current error is set as a child of the new [`Report`].
    ///
    /// This is similar to [`local_context`](ResultExt::local_context), but the context is computed lazily using
    /// a closure. This can be useful when computing the context is expensive, as the
    /// closure will only be called if an error actually occurs.
    ///
    /// This method also works when the original error is a [`ReportCollection`], in which case all
    /// errors in that collection are set as children of the new [`Report`].
    ///
    /// See also [`context_with`](ResultExt::context_with) for a thread-safe version that returns a [`Report`]
    /// that can be sent across thread boundaries.
    ///
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// # #[derive(Debug)]
    /// # struct Expensive;
    /// use std::rc::Rc;
    ///
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// struct SomeObject(Rc<Expensive>);
    ///
    /// impl SomeObject {
    ///     fn compute_or_get_cached() -> Self {
    ///         // ...
    /// #       Self(Rc::new(Expensive))
    ///     }
    /// }
    ///
    /// impl std::fmt::Display for SomeObject {
    ///     // ...
    /// #   fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { todo!() }
    /// }
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<SomeObject, _, markers::Local>> =
    ///     result.local_context_with(|| SomeObject::compute_or_get_cached());
    /// ```
    #[track_caller]
    fn local_context_with<C, F>(self, context: F) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        F: FnOnce() -> C,
        C: ObjectMarker + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a new local (non-thread-safe) [`Report`] using the provided context.
    /// The current error is set as a child of the new [`Report`].
    ///
    /// This is similar to [`local_context`](ResultExt::local_context), but uses a custom [`ContextHandler`] to control
    /// how the context is formatted and displayed.
    ///
    /// This method also works when the original error is a [`ReportCollection`], in which case all
    /// errors in that collection are set as children of the new [`Report`].
    ///
    /// See also [`context_custom`](ResultExt::context_custom) for a thread-safe version that returns a [`Report`]
    /// that can be sent across thread boundaries.
    ///
    /// [`ContextHandler`]: handlers::ContextHandler
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// use std::rc::Rc;
    ///
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// enum ErrorContext {
    ///     DeserializationError,
    ///     IoError,
    /// }
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<Rc<ErrorContext>, _, markers::Local>> =
    ///     result.local_context_custom::<handlers::Debug, _>(Rc::new(ErrorContext::IoError));
    /// ```
    #[track_caller]
    fn local_context_custom<H, C>(self, context: C) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        C: ObjectMarker,
        H: handlers::ContextHandler<C>;

    /// Converts the error into a new local (non-thread-safe) [`Report`] using context generated by the provided closure.
    /// The current error is set as a child of the new [`Report`].
    ///
    /// Combines the lazy evaluation of [`local_context_with`](ResultExt::local_context_with) with the custom
    /// handler capabilities of [`local_context_custom`](ResultExt::local_context_custom).
    ///
    /// This method also works when the original error is a [`ReportCollection`], in which case all
    /// errors in that collection are set as children of the new [`Report`].
    ///
    /// See also [`context_custom_with`](ResultExt::context_custom_with) for a thread-safe version that returns a [`Report`]
    /// that can be sent across thread boundaries.
    ///
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// # fn expensive_computation() -> Rc<ErrorContext> { Rc::new(ErrorContext {}) }
    /// use std::rc::Rc;
    ///
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// struct ErrorContext {
    ///     // ...
    /// }
    ///
    /// impl ErrorContext {
    ///     pub fn new() -> Rc<Self> {
    ///         expensive_computation()
    ///     }
    /// }
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<Rc<ErrorContext>, _, markers::Local>> =
    ///     result.local_context_custom_with::<handlers::Debug, _, _>(|| ErrorContext::new());
    /// ```
    #[track_caller]
    fn local_context_custom_with<H, C, F>(self, context: F) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        F: FnOnce() -> C,
        C: ObjectMarker,
        H: handlers::ContextHandler<C>;

    /// Converts the error into a local (non-thread-safe) [`Report`] and adds the provided attachment to the [`Report`].
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is `Err`,
    /// converts the error into a [`Report`] and attaches the provided data as an attachment.
    /// Attachments provide additional context without changing the primary error message.
    ///
    /// See also [`attach`](ResultExt::attach) for a thread-safe version that returns a [`Report`]
    /// that can be sent across thread boundaries.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::rc::Rc;
    ///
    /// use rootcause::prelude::*;
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<std::io::Error, _, markers::Local>> =
    ///     result.local_attach(Rc::new("input: invalid_data"));
    /// ```
    #[track_caller]
    fn local_attach<A>(self, attachment: A) -> Result<V, Report<E::Context, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        A: ObjectMarker + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a local (non-thread-safe) [`Report`] and adds an attachment generated by the provided closure to the [`Report`].
    ///
    /// This is similar to [`local_attach`](ResultExt::local_attach), but the attachment is computed lazily using
    /// a closure. This can be useful when computing the attachment is expensive, as the
    /// closure will only be called if an error actually occurs.
    ///
    /// See also [`attach_with`](ResultExt::attach_with) for a thread-safe version that returns a [`Report`]
    /// that can be sent across thread boundaries.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::rc::Rc;
    ///
    /// use rootcause::prelude::*;
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<std::io::Error, _, markers::Local>> =
    ///     result.local_attach_with(|| Rc::new(format!("debug info: {}", "complex computation")));
    /// ```
    #[track_caller]
    fn local_attach_with<A, F>(
        self,
        attachment: F,
    ) -> Result<V, Report<E::Context, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: ObjectMarker + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a local (non-thread-safe) [`Report`] and adds the provided attachment to the [`Report`].
    ///
    /// This is similar to [`local_attach`](ResultExt::local_attach), but uses a custom [`AttachmentHandler`] to control
    /// how the attachment is formatted and displayed.
    ///
    /// See also [`attach_custom`](ResultExt::attach_custom) for a thread-safe version that returns a [`Report`]
    /// that can be sent across thread boundaries.
    ///
    /// [`AttachmentHandler`]: handlers::AttachmentHandler
    ///
    /// # Examples
    ///
    /// ```
    /// use std::rc::Rc;
    ///
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// struct MyAttachment {
    ///     // ...
    /// }
    /// # impl MyAttachment {
    /// #     fn new() -> Self { MyAttachment {} }
    /// # }
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<std::io::Error, _, markers::Local>> =
    ///     result.local_attach_custom::<handlers::Debug, _>(Rc::new(MyAttachment::new()));
    /// ```
    #[track_caller]
    fn local_attach_custom<H, A>(
        self,
        attachment: A,
    ) -> Result<V, Report<E::Context, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        A: ObjectMarker,
        H: handlers::AttachmentHandler<A>;

    /// Converts the error into a local (non-thread-safe) [`Report`] and adds an attachment generated by the provided closure to the [`Report`].
    ///
    /// Combines the lazy evaluation of [`local_attach_with`](ResultExt::local_attach_with) with the custom
    /// handler capabilities of [`local_attach_custom`](ResultExt::local_attach_custom).
    ///
    /// See also [`attach_custom_with`](ResultExt::attach_custom_with) for a thread-safe version that returns a [`Report`]
    /// that can be sent across thread boundaries.
    ///
    /// # Examples
    ///
    /// ```
    /// # fn expensive_computation() -> MyAttachment { MyAttachment {} }
    /// use std::rc::Rc;
    ///
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// struct MyAttachment {
    ///     // ...
    /// }
    ///
    /// impl MyAttachment {
    ///     pub fn new() -> Self {
    ///         expensive_computation()
    ///     }
    /// }
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<std::io::Error, _, markers::Local>> = result
    ///     .local_attach_custom_with::<handlers::Debug, _, _>(
    ///     || Rc::new(MyAttachment::new()),
    /// );
    /// ```
    #[track_caller]
    fn local_attach_custom_with<H, A, F>(
        self,
        attachment: F,
    ) -> Result<V, Report<E::Context, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: ObjectMarker,
        H: handlers::AttachmentHandler<A>;
}

impl<V, E> ResultExt<V, E> for Result<V, E> {
    #[inline(always)]
    fn into_report(self) -> Result<V, Report<E::Context, E::Ownership, SendSync>>
    where
        E: IntoReport<SendSync>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report()),
        }
    }

    #[inline(always)]
    fn context<C>(self, context: C) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        C: ObjectMarker + Send + Sync + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report_collection().context(context)),
        }
    }

    #[inline(always)]
    fn context_with<C, F>(self, context: F) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        F: FnOnce() -> C,
        C: ObjectMarker + Send + Sync + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report_collection().context(context())),
        }
    }

    #[inline(always)]
    fn context_custom<H, C>(self, context: C) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        C: ObjectMarker + Send + Sync,
        H: handlers::ContextHandler<C>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report_collection().context_custom::<H, _>(context)),
        }
    }

    #[inline(always)]
    fn context_custom_with<H, C, F>(self, context: F) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        F: FnOnce() -> C,
        C: ObjectMarker + Send + Sync,
        H: handlers::ContextHandler<C>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report_collection().context_custom::<H, _>(context())),
        }
    }

    #[inline(always)]
    fn attach<A>(self, attachment: A) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        A: ObjectMarker + Send + Sync + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach(attachment)),
        }
    }

    #[inline(always)]
    fn attach_with<A, F>(self, attachment: F) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: ObjectMarker + Send + Sync + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach(attachment())),
        }
    }

    #[inline(always)]
    fn attach_custom<H, A>(self, attachment: A) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        A: ObjectMarker + Send + Sync,
        H: handlers::AttachmentHandler<A>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach_custom::<H, _>(attachment)),
        }
    }

    #[inline(always)]
    fn attach_custom_with<H, A, F>(
        self,
        attachment: F,
    ) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: ObjectMarker + Send + Sync,
        H: handlers::AttachmentHandler<A>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach_custom::<H, _>(attachment())),
        }
    }

    #[inline(always)]
    fn local_into_report(self) -> Result<V, Report<E::Context, E::Ownership, Local>>
    where
        E: IntoReport<Local>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report()),
        }
    }

    #[inline(always)]
    fn local_context<C>(self, context: C) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        C: ObjectMarker + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report_collection().context(context)),
        }
    }

    #[inline(always)]
    fn local_context_with<C, F>(self, context: F) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        F: FnOnce() -> C,
        C: ObjectMarker + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report_collection().context(context())),
        }
    }

    #[inline(always)]
    fn local_context_custom<H, C>(self, context: C) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        C: ObjectMarker,
        H: handlers::ContextHandler<C>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report_collection().context_custom::<H, _>(context)),
        }
    }

    #[inline(always)]
    fn local_context_custom_with<H, C, F>(self, context: F) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        F: FnOnce() -> C,
        C: ObjectMarker,
        H: handlers::ContextHandler<C>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report_collection().context_custom::<H, _>(context())),
        }
    }

    #[inline(always)]
    fn local_attach<A>(self, attachment: A) -> Result<V, Report<<E>::Context, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        A: ObjectMarker + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach(attachment)),
        }
    }

    #[inline(always)]
    fn local_attach_with<A, F>(
        self,
        attachment: F,
    ) -> Result<V, Report<<E>::Context, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: ObjectMarker + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach(attachment())),
        }
    }

    #[inline(always)]
    fn local_attach_custom<H, A>(
        self,
        attachment: A,
    ) -> Result<V, Report<<E>::Context, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        A: ObjectMarker,
        H: handlers::AttachmentHandler<A>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach_custom::<H, _>(attachment)),
        }
    }

    #[inline(always)]
    fn local_attach_custom_with<H, A, F>(
        self,
        attachment: F,
    ) -> Result<V, Report<<E>::Context, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: ObjectMarker,
        H: handlers::AttachmentHandler<A>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach_custom::<H, _>(attachment())),
        }
    }
}
