use rootcause_internals::handlers;

use crate::{
    IntoReport, Report, ReportConversion,
    into_report::IntoReportCollection,
    markers::{Local, Mutable, SendSync},
};

mod sealed {
    pub trait Sealed {}
    impl<A, E> Sealed for Result<A, E> {}
}

/// Extension trait for `Result` that provides error handling and reporting
/// functionality.
///
/// This trait adds methods to `Result` types that allow you to convert errors
/// into [`Report`]s with additional context and attachments. It provides both
/// thread-safe (`Send + Sync`) and local-only variants of each method.
///
/// The methods in this trait fall into several categories:
///
/// - **Converting to reports**: [`into_report`](ResultExt::into_report)
///   converts the error into a [`Report`]
/// - **Adding context**: [`context`](ResultExt::context),
///   [`context_with`](ResultExt::context_with), and variants add a new context
///   layer to the error
/// - **Adding attachments**: [`attach`](ResultExt::attach),
///   [`attach_with`](ResultExt::attach_with), and variants add supplementary
///   data to the error
///
/// Each method has a `local_*` variant for working with types that are not
/// `Send + Sync`.
pub trait ResultExt<V, E>: sealed::Sealed {
    /// Converts the error into a [`Report`].
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is
    /// `Err`, converts the error into a [`Report`].
    ///
    /// See also [`local_into_report`](ResultExt::local_into_report) for a
    /// non-thread-safe version that works with types that are not
    /// `Send + Sync`.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::io;
    ///
    /// use rootcause::prelude::*;
    ///
    /// fn read_config() -> Result<String, io::Error> {
    ///     std::fs::read_to_string("config.toml")
    /// }
    ///
    /// let result: Result<String, Report<io::Error>> = read_config().into_report();
    /// ```
    #[track_caller]
    fn into_report(self) -> Result<V, Report<E::Context, E::Ownership, SendSync>>
    where
        E: IntoReport<SendSync>;

    /// Converts the error into a new [`Report`] using the provided context. The
    /// current error is set as a child of the new [`Report`].
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is
    /// `Err`, converts the error into a report collection and adds the
    /// provided context. The context becomes the primary error message,
    /// with the original error becoming part of the error chain.
    ///
    /// This method also works when the original error is a
    /// [`ReportCollection`], in which case all errors in that collection
    /// are set as children of the new [`Report`].
    ///
    /// See also [`local_context`](ResultExt::local_context) for a
    /// non-thread-safe version that works with types that are not
    /// `Send + Sync`.
    ///
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// use std::io;
    ///
    /// use rootcause::prelude::*;
    ///
    /// fn fetch_data(path: &str) -> Result<Vec<u8>, io::Error> {
    ///     std::fs::read(path)
    /// }
    ///
    /// let result: Result<Vec<u8>, Report<&str>> =
    ///     fetch_data("user_data.bz2").context("Failed to fetch user data");
    /// ```
    #[track_caller]
    fn context<C>(self, context: C) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        C: Send + Sync + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a new [`Report`] using context generated by the
    /// provided closure. The current error is set as a child of the new
    /// [`Report`].
    ///
    /// This is similar to [`context`](ResultExt::context), but the context is
    /// computed lazily using a closure. This can be useful when computing
    /// the context is expensive, as the closure will only be called if an
    /// error actually occurs.
    ///
    /// This method also works when the original error is a
    /// [`ReportCollection`], in which case all errors in that collection
    /// are set as children of the new [`Report`].
    ///
    /// See also [`local_context_with`](ResultExt::local_context_with) for a
    /// non-thread-safe version that works with types that are not
    /// `Send + Sync`.
    ///
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// use std::io;
    ///
    /// use rootcause::prelude::*;
    ///
    /// fn get_timestamp() -> String {
    ///     "12:34:56".to_string()
    /// }
    ///
    /// let result: Result<Vec<u8>, Report<String>> =
    ///     std::fs::read("user_data.bz2").context_with(|| format!("Failed at {}", get_timestamp()));
    /// ```
    #[track_caller]
    fn context_with<C, F>(self, context: F) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        F: FnOnce() -> C,
        C: Send + Sync + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a new [`Report`] using the provided context.
    /// The current error is set as a child of the new [`Report`].
    ///
    /// This is similar to [`context`](ResultExt::context), but uses a custom
    /// [`ContextHandler`] to control how the context is formatted and
    /// displayed.
    ///
    /// This method also works when the original error is a
    /// [`ReportCollection`], in which case all errors in that collection
    /// are set as children of the new [`Report`].
    ///
    /// See also [`local_context_custom`](ResultExt::local_context_custom) for a
    /// non-thread-safe version that works with types that are not
    /// `Send + Sync`.
    ///
    /// [`ContextHandler`]: handlers::ContextHandler
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// use std::io;
    ///
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// enum ErrorContext {
    ///     DeserializationError,
    ///     IoError,
    /// }
    ///
    /// let result: Result<Vec<u8>, Report<ErrorContext>> =
    ///     std::fs::read("user_data.bz2").context_custom::<handlers::Debug, _>(ErrorContext::IoError);
    /// ```
    #[track_caller]
    fn context_custom<H, C>(self, context: C) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        C: Send + Sync,
        H: handlers::ContextHandler<C>;

    /// Converts the error into a new [`Report`] using context generated by the
    /// provided closure. The current error is set as a child of the new
    /// [`Report`].
    ///
    /// Combines the lazy evaluation of
    /// [`context_with`](ResultExt::context_with) with the custom
    /// handler capabilities of [`context_custom`](ResultExt::context_custom).
    ///
    /// This method also works when the original error is a
    /// [`ReportCollection`], in which case all errors in that collection
    /// are set as children of the new [`Report`].
    ///
    /// See also [`local_context_custom_with`](ResultExt::local_context_custom_with)
    /// for a non-thread-safe version that works with types that are not
    /// `Send + Sync`.
    ///
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// use std::io;
    ///
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// struct ErrorContext {
    ///     timestamp: String,
    ///     operation: String,
    /// }
    ///
    /// fn expensive_computation() -> ErrorContext {
    ///     ErrorContext {
    ///         timestamp: "12:34:56".to_string(),
    ///         operation: "file_read".to_string(),
    ///     }
    /// }
    ///
    /// let result: Result<Vec<u8>, Report<ErrorContext>> =
    ///     std::fs::read("user_data.bz2")
    ///         .context_custom_with::<handlers::Debug, _, _>(expensive_computation);
    /// ```
    #[track_caller]
    fn context_custom_with<H, C, F>(self, context: F) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        F: FnOnce() -> C,
        C: Send + Sync,
        H: handlers::ContextHandler<C>;

    /// Converts the error to a different context type using a
    /// [`ReportConversion`] implementation.
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is
    /// `Err`, converts the error into a [`Report`] and then transforms it to a
    /// different context type using the [`ReportConversion`] trait
    /// implementation.
    ///
    /// Implement [`ReportConversion`] once to define how errors convert, then
    /// use `context_to()` throughout your code to apply that conversion.
    ///
    /// See [`examples/context_methods.rs`] for choosing transformation
    /// strategies, and [`examples/thiserror_interop.rs`] for integration
    /// patterns.
    ///
    /// See also [`local_context_to`](ResultExt::local_context_to) for a
    /// non-thread-safe version that works with types that are not
    /// `Send + Sync`.
    ///
    /// [`ReportConversion`]: crate::ReportConversion
    /// [`examples/context_methods.rs`]: https://github.com/rootcause-rs/rootcause/blob/main/examples/context_methods.rs
    /// [`examples/thiserror_interop.rs`]: https://github.com/rootcause-rs/rootcause/blob/main/examples/thiserror_interop.rs
    ///
    /// # Type Inference
    ///
    /// The target context type `C` is typically inferred from the return type,
    /// but you may need to specify it explicitly using turbofish syntax if the
    /// compiler cannot infer it.
    ///
    /// # Examples
    ///
    /// ```
    /// # use rootcause::{ReportConversion, markers, prelude::*};
    /// # #[derive(Debug)]
    /// # enum AppError { Parse }
    /// # impl std::fmt::Display for AppError {
    /// #     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, "error") }
    /// # }
    /// # impl<O, T> ReportConversion<std::num::ParseIntError, O, T> for AppError
    /// #   where AppError: markers::ObjectMarkerFor<T>
    /// # {
    /// #     fn convert_report(report: Report<std::num::ParseIntError, O, T>) -> Report<Self, markers::Mutable, T>
    /// #     {
    /// #         report.context(AppError::Parse)
    /// #     }
    /// # }
    /// // After implementing ReportConversion, use at call sites:
    /// let result: Result<i32, Report<AppError>> = "abc".parse::<i32>().context_to();
    /// ```
    #[track_caller]
    fn context_to<C>(self) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReport<SendSync>,
        C: ReportConversion<E::Context, E::Ownership, SendSync>;

    /// Transforms the error's context using a closure, preserving the report
    /// structure.
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is
    /// `Err`, converts the error into a [`Report`] and applies the provided
    /// closure to transform the context, while keeping all children and
    /// attachments intact. The transformation bypasses the report creation
    /// hook.
    ///
    /// Unlike [`context()`](ResultExt::context) which wraps the error as a
    /// child, this method replaces the context in-place.
    ///
    /// See [`examples/context_methods.rs`] for guidance on choosing between
    /// this, [`context_transform_nested()`](ResultExt::context_transform_nested),
    /// and [`context()`](ResultExt::context).
    ///
    /// See also [`local_context_transform`](ResultExt::local_context_transform)
    /// for a non-thread-safe version.
    ///
    /// [`examples/context_methods.rs`]: https://github.com/rootcause-rs/rootcause/blob/main/examples/context_methods.rs
    ///
    /// # Examples
    ///
    /// ```
    /// # use std::io;
    /// # use rootcause::prelude::*;
    /// # #[derive(Debug)]
    /// # enum AppError { Io(io::Error) }
    /// # impl std::fmt::Display for AppError {
    /// #     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, "error") }
    /// # }
    /// let result: Result<String, Report<AppError>> =
    ///     std::fs::read_to_string("config.toml").context_transform(AppError::Io);
    /// ```
    #[track_caller]
    fn context_transform<C, F>(self, f: F) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        E::Context: Sized,
        F: FnOnce(E::Context) -> C,
        C: Send + Sync + core::fmt::Display + core::fmt::Debug;

    /// Transforms the error's context while nesting the entire original
    /// report structure as a child.
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is
    /// `Err`, converts the error into a [`Report`], preformats it, and wraps
    /// the entire preformatted report as a child under the new context created
    /// by the provided closure. Since this uses
    /// [`context()`](ResultExt::context) internally, report creation hooks
    /// run again, capturing fresh hook data at the transformation point.
    ///
    /// See [`examples/context_methods.rs`] for guidance on choosing between
    /// this, [`context_transform()`](ResultExt::context_transform), and
    /// [`context()`](ResultExt::context).
    ///
    /// See also
    /// [`local_context_transform_nested`](ResultExt::local_context_transform_nested)
    /// for a non-thread-safe version.
    ///
    /// [`examples/context_methods.rs`]: https://github.com/rootcause-rs/rootcause/blob/main/examples/context_methods.rs
    ///
    /// # Examples
    ///
    /// ```
    /// # use std::io;
    /// # use rootcause::prelude::*;
    /// # #[derive(Debug)]
    /// # enum AppError { Io(io::Error) }
    /// # impl std::fmt::Display for AppError {
    /// #     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, "error") }
    /// # }
    /// let result: Result<String, Report<AppError>> =
    ///     std::fs::read_to_string("config.toml").context_transform_nested(AppError::Io);
    /// ```
    #[track_caller]
    fn context_transform_nested<C, F>(self, f: F) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        E::Context: Sized,
        F: FnOnce(E::Context) -> C,
        C: Send + Sync + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a [`Report`] and adds the provided attachment to
    /// the [`Report`].
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is
    /// `Err`, converts the error into a [`Report`] and attaches the
    /// provided data as an attachment. Attachments provide additional
    /// context without changing the primary error message.
    ///
    /// See also [`local_attach`](ResultExt::local_attach) for a non-thread-safe
    /// version that works with types that are not `Send + Sync`.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::io;
    ///
    /// use rootcause::prelude::*;
    ///
    /// let result: Result<Vec<u8>, Report<io::Error>> =
    ///     std::fs::read("user_data.bz2").attach("while reading user_data.bz2");
    /// ```
    #[track_caller]
    fn attach<A>(self, attachment: A) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        A: 'static + Send + Sync + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a [`Report`] and adds an attachment generated by
    /// the provided closure to the [`Report`].
    ///
    /// This is similar to [`attach`](ResultExt::attach), but the attachment is
    /// computed lazily using a closure. This can be useful when computing
    /// the attachment is expensive, as the closure will only be called if
    /// an error actually occurs.
    ///
    /// See also [`local_attach_with`](ResultExt::local_attach_with) for a
    /// non-thread-safe version that works with types that are not
    /// `Send + Sync`.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::io;
    ///
    /// use rootcause::prelude::*;
    ///
    /// fn get_debug_info() -> String {
    ///     "complex computation result".to_string()
    /// }
    ///
    /// let result: Result<Vec<u8>, Report<io::Error>> =
    ///     std::fs::read("user_data.bz2").attach_with(|| format!("debug info: {}", get_debug_info()));
    /// ```
    #[track_caller]
    fn attach_with<A, F>(self, attachment: F) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: 'static + Send + Sync + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a [`Report`] and adds the provided attachment to
    /// the [`Report`].
    ///
    /// This is similar to [`attach`](ResultExt::attach), but uses a custom
    /// [`AttachmentHandler`] to control how the attachment is formatted and
    /// displayed.
    ///
    /// See also [`local_attach_custom`](ResultExt::local_attach_custom) for a
    /// non-thread-safe version that works with types that are not
    /// `Send + Sync`.
    ///
    /// [`AttachmentHandler`]: handlers::AttachmentHandler
    ///
    /// # Examples
    ///
    /// ```
    /// use std::io;
    ///
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// struct RequestMetadata {
    ///     request_id: u64,
    ///     user_id: u64,
    /// }
    ///
    /// let metadata = RequestMetadata {
    ///     request_id: 12345,
    ///     user_id: 67890,
    /// };
    ///
    /// let result: Result<Vec<u8>, Report<io::Error>> =
    ///     std::fs::read("user_data.bz2").attach_custom::<handlers::Debug, _>(metadata);
    /// ```
    #[track_caller]
    fn attach_custom<H, A>(self, attachment: A) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        A: 'static + Send + Sync,
        H: handlers::AttachmentHandler<A>;

    /// Converts the error into a [`Report`] and adds an attachment generated by
    /// the provided closure to the [`Report`].
    ///
    /// Combines the lazy evaluation of [`attach_with`](ResultExt::attach_with)
    /// with the custom handler capabilities of
    /// [`attach_custom`](ResultExt::attach_custom).
    ///
    /// See also [`local_attach_custom_with`](ResultExt::local_attach_custom_with)
    /// for a non-thread-safe version that works with types that are not
    /// `Send + Sync`.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::io;
    ///
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// struct RequestMetadata {
    ///     request_id: u64,
    ///     timestamp: String,
    /// }
    ///
    /// fn expensive_computation() -> RequestMetadata {
    ///     RequestMetadata {
    ///         request_id: 12345,
    ///         timestamp: "12:34:56".to_string(),
    ///     }
    /// }
    ///
    /// let result: Result<Vec<u8>, Report<io::Error>> = std::fs::read("user_data.bz2")
    ///     .attach_custom_with::<handlers::Debug, _, _>(expensive_computation);
    /// ```
    #[track_caller]
    fn attach_custom_with<H, A, F>(
        self,
        attachment: F,
    ) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: 'static + Send + Sync,
        H: handlers::AttachmentHandler<A>;

    /// Converts the error into a local (non-thread-safe) [`Report`].
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is
    /// `Err`, converts the error into a [`Report`] that can contain types
    /// that are not `Send + Sync`.
    ///
    /// This allows you to use rootcause with error types that contain
    /// thread-local data like [`Rc`](std::rc::Rc) or other `!Send` types.
    ///
    /// See also [`into_report`](ResultExt::into_report) for a thread-safe
    /// version that returns a [`Report`] that can be sent across thread
    /// boundaries.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::{fmt, rc::Rc};
    ///
    /// use rootcause::prelude::*;
    ///
    /// // This error is neither Send nor Sync
    /// #[derive(Debug)]
    /// struct MyError(Rc<String>);
    ///
    /// impl fmt::Display for MyError {
    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    ///         write!(f, "{}", self.0)
    ///     }
    /// }
    ///
    /// impl std::error::Error for MyError {}
    ///
    /// fn some_function() -> Result<String, MyError> {
    ///     Err(MyError(Rc::new("error".to_string())))
    /// }
    ///
    /// let result: Result<String, Report<MyError, _, markers::Local>> =
    ///     some_function().local_into_report();
    /// ```
    #[track_caller]
    fn local_into_report(self) -> Result<V, Report<E::Context, E::Ownership, Local>>
    where
        E: IntoReport<Local>;

    /// Converts the error into a new local (non-thread-safe) [`Report`] using
    /// the provided context. The current error is set as a child of the new
    /// [`Report`].
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is
    /// `Err`, converts the error into a report collection and adds the
    /// provided context. The context becomes the primary error message,
    /// with the original error becoming part of the error chain.
    ///
    /// This method also works when the original error is a
    /// [`ReportCollection`], in which case all errors in that collection
    /// are set as children of the new [`Report`].
    ///
    /// See also [`context`](ResultExt::context) for a thread-safe version that
    /// returns a [`Report`] that can be sent across thread boundaries.
    ///
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// use std::{io, rc::Rc};
    ///
    /// use rootcause::prelude::*;
    ///
    /// fn fetch_data(path: &str) -> Result<Vec<u8>, io::Error> {
    ///     std::fs::read(path)
    /// }
    ///
    /// let result: Result<Vec<u8>, Report<Rc<&str>, _, markers::Local>> =
    ///     fetch_data("user_data.bz2").local_context(Rc::from("Failed to fetch user data"));
    /// ```
    #[track_caller]
    fn local_context<C>(self, context: C) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        C: core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a new local (non-thread-safe) [`Report`] using
    /// context generated by the provided closure. The current error is set
    /// as a child of the new [`Report`].
    ///
    /// This is similar to [`local_context`](ResultExt::local_context), but the
    /// context is computed lazily using a closure. This can be useful when
    /// computing the context is expensive, as the closure will only be
    /// called if an error actually occurs.
    ///
    /// This method also works when the original error is a
    /// [`ReportCollection`], in which case all errors in that collection
    /// are set as children of the new [`Report`].
    ///
    /// See also [`context_with`](ResultExt::context_with) for a thread-safe
    /// version that returns a [`Report`] that can be sent across thread
    /// boundaries.
    ///
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// use std::{io, rc::Rc};
    ///
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// struct ContextData {
    ///     timestamp: Rc<String>,
    ///     operation: String,
    /// }
    ///
    /// impl std::fmt::Display for ContextData {
    ///     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    ///         write!(f, "{}: {}", self.timestamp, self.operation)
    ///     }
    /// }
    ///
    /// fn expensive_computation() -> ContextData {
    ///     // Expensive computation that builds context data
    ///     ContextData {
    ///         timestamp: Rc::new("12:34:56".to_string()),
    ///         operation: "file_read".to_string(),
    ///     }
    /// }
    ///
    /// let result: Result<Vec<u8>, Report<ContextData, _, markers::Local>> =
    ///     std::fs::read("user_data.bz2").local_context_with(expensive_computation);
    /// ```
    #[track_caller]
    fn local_context_with<C, F>(self, context: F) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        F: FnOnce() -> C,
        C: core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a new local (non-thread-safe) [`Report`] using
    /// the provided context. The current error is set as a child of the new
    /// [`Report`].
    ///
    /// This is similar to [`local_context`](ResultExt::local_context), but uses
    /// a custom [`ContextHandler`] to control how the context is formatted
    /// and displayed.
    ///
    /// This method also works when the original error is a
    /// [`ReportCollection`], in which case all errors in that collection
    /// are set as children of the new [`Report`].
    ///
    /// See also [`context_custom`](ResultExt::context_custom) for a thread-safe
    /// version that returns a [`Report`] that can be sent across thread
    /// boundaries.
    ///
    /// [`ContextHandler`]: handlers::ContextHandler
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// use std::{io, rc::Rc};
    ///
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// enum ErrorContext {
    ///     DeserializationError,
    ///     IoError,
    /// }
    ///
    /// let result: Result<Vec<u8>, Report<Rc<ErrorContext>, _, markers::Local>> =
    ///     std::fs::read("user_data.bz2")
    ///         .local_context_custom::<handlers::Debug, _>(Rc::new(ErrorContext::IoError));
    /// ```
    #[track_caller]
    fn local_context_custom<H, C>(self, context: C) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        H: handlers::ContextHandler<C>;

    /// Converts the error into a new local (non-thread-safe) [`Report`] using
    /// context generated by the provided closure. The current error is set
    /// as a child of the new [`Report`].
    ///
    /// Combines the lazy evaluation of
    /// [`local_context_with`](ResultExt::local_context_with) with the custom
    /// handler capabilities of
    /// [`local_context_custom`](ResultExt::local_context_custom).
    ///
    /// This method also works when the original error is a
    /// [`ReportCollection`], in which case all errors in that collection
    /// are set as children of the new [`Report`].
    ///
    /// See also [`context_custom_with`](ResultExt::context_custom_with) for a
    /// thread-safe version that returns a [`Report`] that can be sent
    /// across thread boundaries.
    ///
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// use std::{io, rc::Rc};
    ///
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// struct ErrorContext {
    ///     timestamp: Rc<String>,
    ///     operation: String,
    /// }
    ///
    /// fn expensive_computation() -> Rc<ErrorContext> {
    ///     Rc::new(ErrorContext {
    ///         timestamp: Rc::new("12:34:56".to_string()),
    ///         operation: "file_read".to_string(),
    ///     })
    /// }
    ///
    /// let result: Result<Vec<u8>, Report<Rc<ErrorContext>, _, markers::Local>> =
    ///     std::fs::read("user_data.bz2")
    ///         .local_context_custom_with::<handlers::Debug, _, _>(expensive_computation);
    /// ```
    #[track_caller]
    fn local_context_custom_with<H, C, F>(self, context: F) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        F: FnOnce() -> C,
        H: handlers::ContextHandler<C>;

    /// Converts the error to a different context type using a
    /// [`ReportConversion`] implementation, producing a non-thread-safe
    /// [`Report`].
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is
    /// `Err`, converts the error into a local (non-thread-safe) [`Report`] and
    /// then transforms it to a different context type using the
    /// [`ReportConversion`] trait implementation.
    ///
    /// This method is the non-thread-safe version of
    /// [`context_to`](ResultExt::context_to), allowing you to work with context
    /// types that are not `Send + Sync`.
    ///
    /// See also [`context_to`](ResultExt::context_to) for a thread-safe version
    /// that returns a [`Report`] that can be sent across thread boundaries.
    ///
    /// [`ReportConversion`]: crate::ReportConversion
    ///
    /// # Type Inference
    ///
    /// The target context type `C` is typically inferred from the return type,
    /// but you may need to specify it explicitly using turbofish syntax if the
    /// compiler cannot infer it.
    ///
    /// # Examples
    ///
    /// ```
    /// # use std::rc::Rc;
    /// # use rootcause::{ReportConversion, markers, prelude::*};
    /// # #[derive(Debug)]
    /// # struct LocalError(Rc<str>);
    /// # impl std::fmt::Display for LocalError {
    /// #     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, "error") }
    /// # }
    /// # impl<O> ReportConversion<std::num::ParseIntError, O, markers::Local> for LocalError {
    /// #     fn convert_report(report: Report<std::num::ParseIntError, O, markers::Local>) -> Report<Self, markers::Mutable, markers::Local>
    /// #     {
    /// #         report.context(LocalError(Rc::from("error")))
    /// #     }
    /// # }
    /// // After implementing ReportConversion:
    /// let result: Result<i32, Report<LocalError, _, markers::Local>> = "abc".parse::<i32>().local_context_to();
    /// ```
    #[track_caller]
    fn local_context_to<C>(self) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReport<Local>,
        C: ReportConversion<E::Context, E::Ownership, Local>;

    /// Transforms the error's context using a closure, preserving the report
    /// structure (non-thread-safe version).
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is
    /// `Err`, converts the error into a local (non-thread-safe) [`Report`] and
    /// applies the provided closure to transform the context, while keeping all
    /// children and attachments intact. The transformation bypasses the report
    /// creation hook.
    ///
    /// This is the non-thread-safe version of
    /// [`context_transform`](ResultExt::context_transform), allowing you to
    /// work with context types that are not `Send + Sync`.
    ///
    /// See also [`context_transform`](ResultExt::context_transform) for a
    /// thread-safe version.
    ///
    /// # Examples
    ///
    /// ```
    /// # use std::{io, rc::Rc};
    /// # use rootcause::prelude::*;
    /// # #[derive(Debug)]
    /// # enum AppError { Io(Rc<io::Error>) }
    /// # impl std::fmt::Display for AppError {
    /// #     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, "error") }
    /// # }
    /// let result: Result<String, Report<AppError, _, markers::Local>> =
    ///     std::fs::read_to_string("config.toml").local_context_transform(|e| AppError::Io(Rc::new(e)));
    /// ```
    #[track_caller]
    fn local_context_transform<C, F>(self, f: F) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        E::Context: Sized,
        F: FnOnce(E::Context) -> C,
        C: core::fmt::Display + core::fmt::Debug;

    /// Transforms the error's context while nesting the entire original
    /// report structure as a child (non-thread-safe version).
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is
    /// `Err`, converts the error into a local (non-thread-safe) [`Report`],
    /// preformats it, and wraps the entire preformatted report as a child under
    /// the new context created by the provided closure. Since this uses
    /// [`local_context()`](ResultExt::local_context) internally, report
    /// creation hooks run again.
    ///
    /// This is the non-thread-safe version of
    /// [`context_transform_nested`](ResultExt::context_transform_nested),
    /// allowing you to work with context types that are not `Send + Sync`.
    ///
    /// See also
    /// [`context_transform_nested`](ResultExt::context_transform_nested)
    /// for a thread-safe version.
    ///
    /// # Examples
    ///
    /// ```
    /// # use std::{io, rc::Rc};
    /// # use rootcause::prelude::*;
    /// # #[derive(Debug)]
    /// # enum AppError { Io(Rc<io::Error>) }
    /// # impl std::fmt::Display for AppError {
    /// #     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result { write!(f, "error") }
    /// # }
    /// let result: Result<String, Report<AppError, _, markers::Local>> =
    ///     std::fs::read_to_string("config.toml").local_context_transform_nested(|e| AppError::Io(Rc::new(e)));
    /// ```
    #[track_caller]
    fn local_context_transform_nested<C, F>(self, f: F) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        E::Context: Sized,
        F: FnOnce(E::Context) -> C,
        C: core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a local (non-thread-safe) [`Report`] and adds
    /// the provided attachment to the [`Report`].
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is
    /// `Err`, converts the error into a [`Report`] and attaches the
    /// provided data as an attachment. Attachments provide additional
    /// context without changing the primary error message.
    ///
    /// See also [`attach`](ResultExt::attach) for a thread-safe version that
    /// returns a [`Report`] that can be sent across thread boundaries.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::{io, rc::Rc};
    ///
    /// use rootcause::prelude::*;
    ///
    /// // In this case it might make more sense to use `local_attach_with`, but
    /// // you can assume that the attachment is pre-computed.
    /// let attachment: Rc<&str> = Rc::from("input: invalid_data");
    /// let result: Result<Vec<u8>, Report<io::Error, _, markers::Local>> =
    ///     std::fs::read("user_data.bz2").local_attach(attachment);
    /// ```
    #[track_caller]
    fn local_attach<A>(self, attachment: A) -> Result<V, Report<E::Context, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        A: 'static + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a local (non-thread-safe) [`Report`] and adds an
    /// attachment generated by the provided closure to the [`Report`].
    ///
    /// This is similar to [`local_attach`](ResultExt::local_attach), but the
    /// attachment is computed lazily using a closure. This can be useful
    /// when computing the attachment is expensive, as the closure will only
    /// be called if an error actually occurs.
    ///
    /// See also [`attach_with`](ResultExt::attach_with) for a thread-safe
    /// version that returns a [`Report`] that can be sent across thread
    /// boundaries.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::{io, rc::Rc};
    ///
    /// use rootcause::prelude::*;
    ///
    /// fn get_debug_info() -> String {
    ///     "complex computation result".to_string()
    /// }
    ///
    /// let result: Result<Vec<u8>, Report<io::Error, _, markers::Local>> =
    ///     std::fs::read("user_data.bz2")
    ///         .local_attach_with(|| Rc::new(format!("debug info: {}", get_debug_info())));
    /// ```
    #[track_caller]
    fn local_attach_with<A, F>(
        self,
        attachment: F,
    ) -> Result<V, Report<E::Context, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: 'static + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a local (non-thread-safe) [`Report`] and adds
    /// the provided attachment to the [`Report`].
    ///
    /// This is similar to [`local_attach`](ResultExt::local_attach), but uses a
    /// custom [`AttachmentHandler`] to control how the attachment is
    /// formatted and displayed.
    ///
    /// See also [`attach_custom`](ResultExt::attach_custom) for a thread-safe
    /// version that returns a [`Report`] that can be sent across thread
    /// boundaries.
    ///
    /// [`AttachmentHandler`]: handlers::AttachmentHandler
    ///
    /// # Examples
    ///
    /// ```
    /// use std::{io, rc::Rc};
    ///
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// struct RequestMetadata {
    ///     request_id: Rc<u64>,
    ///     user_id: u64,
    /// }
    ///
    /// // In this case it might make more sense to use `local_attach_custom_with`, but
    /// // you can assume that the attachment is pre-computed.
    /// let metadata: Rc<RequestMetadata> = Rc::new(RequestMetadata {
    ///     request_id: Rc::new(12345),
    ///     user_id: 67890,
    /// });
    ///
    /// let result: Result<Vec<u8>, Report<io::Error, _, markers::Local>> =
    ///     std::fs::read("user_data.bz2").local_attach_custom::<handlers::Debug, _>(metadata);
    /// ```
    #[track_caller]
    fn local_attach_custom<H, A>(
        self,
        attachment: A,
    ) -> Result<V, Report<E::Context, Mutable, Local>>
    where
        A: 'static,
        E: IntoReport<Local, Ownership = Mutable>,
        H: handlers::AttachmentHandler<A>;

    /// Converts the error into a local (non-thread-safe) [`Report`] and adds an
    /// attachment generated by the provided closure to the [`Report`].
    ///
    /// Combines the lazy evaluation of
    /// [`local_attach_with`](ResultExt::local_attach_with) with the custom
    /// handler capabilities of
    /// [`local_attach_custom`](ResultExt::local_attach_custom).
    ///
    /// See also [`attach_custom_with`](ResultExt::attach_custom_with) for a
    /// thread-safe version that returns a [`Report`] that can be sent
    /// across thread boundaries.
    ///
    /// # Examples
    ///
    /// ```
    /// use std::{io, rc::Rc};
    ///
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// struct RequestMetadata {
    ///     request_id: Rc<u64>,
    ///     timestamp: String,
    /// }
    ///
    /// fn expensive_computation() -> RequestMetadata {
    ///     RequestMetadata {
    ///         request_id: Rc::new(12345),
    ///         timestamp: "12:34:56".to_string(),
    ///     }
    /// }
    ///
    /// let result: Result<Vec<u8>, Report<io::Error, _, markers::Local>> =
    ///     std::fs::read("user_data.bz2")
    ///         .local_attach_custom_with::<handlers::Debug, _, _>(|| Rc::new(expensive_computation()));
    /// ```
    #[track_caller]
    fn local_attach_custom_with<H, A, F>(
        self,
        attachment: F,
    ) -> Result<V, Report<E::Context, Mutable, Local>>
    where
        A: 'static,
        E: IntoReport<Local, Ownership = Mutable>,
        F: FnOnce() -> A,
        H: handlers::AttachmentHandler<A>;
}

impl<V, E> ResultExt<V, E> for Result<V, E> {
    #[inline]
    fn into_report(self) -> Result<V, Report<E::Context, E::Ownership, SendSync>>
    where
        E: IntoReport<SendSync>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report()),
        }
    }

    #[inline]
    fn context<C>(self, context: C) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        C: Send + Sync + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report_collection().context(context)),
        }
    }

    #[inline]
    fn context_with<C, F>(self, context: F) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        F: FnOnce() -> C,
        C: Send + Sync + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report_collection().context(context())),
        }
    }

    #[inline]
    fn context_custom<H, C>(self, context: C) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        C: Send + Sync,
        H: handlers::ContextHandler<C>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report_collection().context_custom::<H, _>(context)),
        }
    }

    #[inline]
    fn context_custom_with<H, C, F>(self, context: F) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        F: FnOnce() -> C,
        C: Send + Sync,
        H: handlers::ContextHandler<C>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report_collection().context_custom::<H, _>(context())),
        }
    }

    #[inline]
    fn context_to<C>(self) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReport<SendSync>,
        C: ReportConversion<E::Context, E::Ownership, SendSync>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().context_to()),
        }
    }

    #[inline]
    fn context_transform<C, F>(self, f: F) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        E::Context: Sized,
        F: FnOnce(E::Context) -> C,
        C: Send + Sync + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().context_transform(f)),
        }
    }

    #[inline]
    fn context_transform_nested<C, F>(self, f: F) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        E::Context: Sized,
        F: FnOnce(E::Context) -> C,
        C: Send + Sync + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().context_transform_nested(f)),
        }
    }

    #[inline]
    fn attach<A>(self, attachment: A) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        A: 'static + Send + Sync + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach(attachment)),
        }
    }

    #[inline]
    fn attach_with<A, F>(self, attachment: F) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: 'static + Send + Sync + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach(attachment())),
        }
    }

    #[inline]
    fn attach_custom<H, A>(self, attachment: A) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        A: 'static + Send + Sync,
        H: handlers::AttachmentHandler<A>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach_custom::<H, _>(attachment)),
        }
    }

    #[inline]
    fn attach_custom_with<H, A, F>(
        self,
        attachment: F,
    ) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: 'static + Send + Sync,
        H: handlers::AttachmentHandler<A>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach_custom::<H, _>(attachment())),
        }
    }

    #[inline]
    fn local_into_report(self) -> Result<V, Report<E::Context, E::Ownership, Local>>
    where
        E: IntoReport<Local>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report()),
        }
    }

    #[inline]
    fn local_context<C>(self, context: C) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        C: core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report_collection().context(context)),
        }
    }

    #[inline]
    fn local_context_with<C, F>(self, context: F) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        F: FnOnce() -> C,
        C: core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report_collection().context(context())),
        }
    }

    #[inline]
    fn local_context_custom<H, C>(self, context: C) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        H: handlers::ContextHandler<C>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report_collection().context_custom::<H, _>(context)),
        }
    }

    #[inline]
    fn local_context_custom_with<H, C, F>(self, context: F) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        F: FnOnce() -> C,
        H: handlers::ContextHandler<C>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report_collection().context_custom::<H, _>(context())),
        }
    }

    #[inline]
    fn local_context_to<C>(self) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReport<Local>,
        C: ReportConversion<E::Context, E::Ownership, Local>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().context_to()),
        }
    }

    #[inline]
    fn local_context_transform<C, F>(self, f: F) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        E::Context: Sized,
        F: FnOnce(E::Context) -> C,
        C: core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().context_transform(f)),
        }
    }

    #[inline]
    fn local_context_transform_nested<C, F>(self, f: F) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        E::Context: Sized,
        F: FnOnce(E::Context) -> C,
        C: core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().context_transform_nested(f)),
        }
    }

    #[inline]
    fn local_attach<A>(self, attachment: A) -> Result<V, Report<<E>::Context, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        A: 'static + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach(attachment)),
        }
    }

    #[inline]
    fn local_attach_with<A, F>(
        self,
        attachment: F,
    ) -> Result<V, Report<<E>::Context, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: 'static + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach(attachment())),
        }
    }

    #[inline]
    fn local_attach_custom<H, A>(
        self,
        attachment: A,
    ) -> Result<V, Report<<E>::Context, Mutable, Local>>
    where
        A: 'static,
        E: IntoReport<Local, Ownership = Mutable>,
        H: handlers::AttachmentHandler<A>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach_custom::<H, _>(attachment)),
        }
    }

    #[inline]
    fn local_attach_custom_with<H, A, F>(
        self,
        attachment: F,
    ) -> Result<V, Report<<E>::Context, Mutable, Local>>
    where
        A: 'static,
        E: IntoReport<Local, Ownership = Mutable>,
        F: FnOnce() -> A,
        H: handlers::AttachmentHandler<A>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach_custom::<H, _>(attachment())),
        }
    }
}
