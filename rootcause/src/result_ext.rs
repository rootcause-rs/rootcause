use rootcause_internals::handlers;

use crate::{
    IntoReport,
    into_report::IntoReportCollection,
    markers::{Local, Mutable, ObjectMarker, SendSync},
    report::Report,
};

mod sealed {
    pub trait Sealed {}
    impl<A, E> Sealed for Result<A, E> {}
}

/// Extension trait for `Result` that provides error handling and reporting functionality.
///
/// This trait adds methods to `Result` types that allow converting errors into [`Report`]s
/// with additional context and attachments. It provides both thread-safe (Send + Sync) and
/// local-only variants of each method.
pub trait ResultExt<V, E>: sealed::Sealed {
    /// Converts the error into a [`Report`].
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is `Err`,
    /// converts the error into a [`Report`].
    ///
    /// See also [`local_into_report`](ResultExt::local_into_report) for a non-thread-safe version that works with objects that are not
    /// `Send` and `Sync`.
    ///
    /// # Examples
    ///
    /// ```
    /// # #[derive(Debug)]
    /// # struct SomeError;
    /// # impl std::fmt::Display for SomeError {
    /// #     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    /// #         todo!()
    /// #     }
    /// # }
    /// # impl std::error::Error for SomeError {}
    /// # impl SomeError { fn new(s: &str) -> Self { Self } }
    /// use rootcause::prelude::*;
    ///
    /// let result: Result<i32, SomeError> = Err(SomeError::new("something went wrong"));
    /// let report_result = result.into_report();
    /// assert!(report_result.is_err());
    /// ```
    #[track_caller]
    #[must_use]
    fn into_report(self) -> Result<V, Report<E::Context, E::Ownership, SendSync>>
    where
        E: IntoReport<SendSync>;

    /// Converts the error into a new [`Report`] using the provided context. The current error is set
    /// as a child of the new [`Report`].
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is `Err`,
    /// converts the error into a report collection and adds the provided context.
    /// The context becomes the primary error message, with the original error
    /// becoming part of the error chain.
    ///
    /// This method also works when the original error is a [`ReportCollection`], in which case all
    /// errors in that collection are set as children of the new [`Report`].
    ///
    /// See also [`local_context`](ResultExt::local_context) for a non-thread-safe version that works with objects that are not
    /// `Send` and `Sync`.
    ///
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// # type NetworkError = std::io::Error;
    /// # fn fetch_data(path: &str) -> Result<Vec<u8>, NetworkError> { Ok(Vec::new()) }
    /// use rootcause::prelude::*;
    ///
    /// let result: Result<Vec<u8>, NetworkError> = fetch_data("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<&str>> = result.context("Failed to fetch user data");
    /// ```
    #[track_caller]
    #[must_use]
    fn context<C>(self, context: C) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        C: ObjectMarker + Send + Sync + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a new [`Report`] using context generated by the provided closure.
    /// The current error is set as a child of the new [`Report`].
    ///
    /// This is similar to [`context`](ResultExt::context), but the context is computed lazily using
    /// a closure. This can be useful when computing the context is expensive, as the
    /// closure will only be called if an error actually occurs.
    ///
    /// This method also works when the original error is a [`ReportCollection`], in which case all
    /// errors in that collection are set as children of the new [`Report`].
    ///
    /// See also [`local_context_lazy`](ResultExt::local_context_lazy) for a non-thread-safe version that works with objects that are not
    /// `Send` and `Sync`.
    ///
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// use rootcause::prelude::*;
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<String>> = result.context_lazy(|| format!("Failed at {}", "12:34:56"));
    /// assert!(report_result.is_err());
    /// ```
    #[track_caller]
    #[must_use]
    fn context_lazy<C, F>(self, context: F) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        F: FnOnce() -> C,
        C: ObjectMarker + Send + Sync + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a new [`Report`] using the provided context.
    /// The current error is set as a child of the new [`Report`].
    ///
    /// This is similar to [`context`](ResultExt::context), but uses a custom [`ContextHandler`] to control
    /// how the context is formatted and displayed.
    ///
    /// This method also works when the original error is a [`ReportCollection`], in which case all
    /// errors in that collection are set as children of the new [`Report`].
    ///
    /// See also [`local_context_with_handler`](ResultExt::local_context_with_handler) for a non-thread-safe version that works with objects that are not
    /// `Send` and `Sync`.
    ///
    /// [`ContextHandler`]: handlers::ContextHandler
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// enum ErrorContext {
    ///     DeserializationError,
    ///     IoError,
    /// }
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<ErrorContext>> =
    ///     result.context_with_handler::<handlers::Debug, _>(ErrorContext::IoError);
    /// ```
    #[track_caller]
    #[must_use]
    fn context_with_handler<H, C>(self, context: C) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        C: ObjectMarker + Send + Sync,
        H: handlers::ContextHandler<C>;

    /// Converts the error into a new [`Report`] using context generated by the provided closure.
    /// The current error is set as a child of the new [`Report`].
    ///
    /// Combines the lazy evaluation of [`context_lazy`](ResultExt::context_lazy) with the custom
    /// handler capabilities of [`context_with_handler`](ResultExt::context_with_handler).
    ///
    /// This method also works when the original error is a [`ReportCollection`], in which case all
    /// errors in that collection are set as children of the new [`Report`].
    ///
    /// See also [`local_context_with_handler_lazy`](ResultExt::local_context_with_handler_lazy) for a non-thread-safe version that works with objects that are not
    /// `Send` and `Sync`.
    ///
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// # fn expensive_computation() -> ErrorContext { ErrorContext {} }
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// struct ErrorContext {
    ///     // ...
    /// }
    ///
    /// impl ErrorContext {
    ///     pub fn new() -> Self {
    ///         expensive_computation()
    ///     }
    /// }
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<ErrorContext>> =
    ///     result.context_with_handler_lazy::<handlers::Debug, _, _>(|| ErrorContext::new());
    /// ```
    #[track_caller]
    #[must_use]
    fn context_with_handler_lazy<H, C, F>(
        self,
        context: F,
    ) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        F: FnOnce() -> C,
        C: ObjectMarker + Send + Sync,
        H: handlers::ContextHandler<C>;

    /// Converts the error into a [`Report`] and adds the provided attachment to the [`Report`].
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is `Err`,
    /// converts the error into a [`Report`] and attaches the provided data as an attachment.
    /// Attachments provide additional context without changing the primary error message.
    ///
    /// See also [`local_attach`](ResultExt::local_attach) for a non-thread-safe version that works with objects that are not
    /// `Send` and `Sync`.
    ///
    /// # Examples
    ///
    /// ```
    /// use rootcause::prelude::*;
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<std::io::Error>> =
    ///     result.attach("input: invalid_data");
    /// ```
    #[track_caller]
    #[must_use]
    fn attach<A>(self, attachment: A) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        A: ObjectMarker + Send + Sync + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a [`Report`] and adds an attachment generated by the provided closure to the [`Report`].
    ///
    /// This is similar to [`attach`](ResultExt::attach), but the attachment is computed lazily using
    /// a closure. This can be useful when computing the attachment is expensive, as the
    /// closure will only be called if an error actually occurs.
    ///
    /// See also [`local_attach_lazy`](ResultExt::local_attach_lazy) for a non-thread-safe version that works with objects that are not
    /// `Send` and `Sync`.
    ///
    /// # Examples
    ///
    /// ```
    /// use rootcause::prelude::*;
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result: Result<Vec<u8>, Report<std::io::Error>> =
    ///     result.attach_lazy(|| format!("debug info: {}", "complex computation"));
    /// ```
    #[track_caller]
    #[must_use]
    fn attach_lazy<A, F>(self, attachment: F) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: ObjectMarker + Send + Sync + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a [`Report`] and adds the provided attachment to the [`Report`].
    ///
    /// This is similar to [`attach`](ResultExt::attach), but uses a custom [`AttachmentHandler`] to control
    /// how the attachment is formatted and displayed.
    ///
    /// See also [`local_attach_with_handler`](ResultExt::local_attach_with_handler) for a non-thread-safe version that works with objects that are not
    /// `Send` and `Sync`.
    ///
    /// [`AttachmentHandler`]: handlers::AttachmentHandler
    ///
    /// # Examples
    ///
    /// ```
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// struct MyAttachment {
    ///     // ...
    /// }
    /// # impl MyAttachment {
    /// #     fn new() -> Self { MyAttachment {} }
    /// # }
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result = result.attach_with_handler::<handlers::Debug, _>(MyAttachment::new());
    /// ```
    #[track_caller]
    #[must_use]
    fn attach_with_handler<H, A>(
        self,
        attachment: A,
    ) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        A: ObjectMarker + Send + Sync,
        H: handlers::AttachmentHandler<A>;

    /// Converts the error into a [`Report`] and adds an attachment generated by the provided closure to the [`Report`].
    ///
    /// Combines the lazy evaluation of [`attach_lazy`](ResultExt::attach_lazy) with the custom
    /// handler capabilities of [`attach_with_handler`](ResultExt::attach_with_handler).
    ///
    /// See also [`local_attach_with_handler_lazy`](ResultExt::local_attach_with_handler_lazy) for a non-thread-safe version that works with objects that are not
    /// `Send` and `Sync`.
    ///
    /// # Examples
    ///
    /// ```
    /// # fn expensive_computation() -> MyAttachment { MyAttachment {} }
    /// use rootcause::prelude::*;
    ///
    /// #[derive(Debug)]
    /// struct MyAttachment {
    ///     // ...
    /// }
    ///
    /// impl MyAttachment {
    ///     pub fn new() -> Self {
    ///         expensive_computation()
    ///     }
    /// }
    ///
    /// let result: Result<Vec<u8>, std::io::Error> = std::fs::read("user_data.bz2");
    /// let report_result = result.attach_with_handler_lazy::<handlers::Debug, _, _>(|| MyAttachment::new());
    /// ```
    #[track_caller]
    #[must_use]
    fn attach_with_handler_lazy<H, A, F>(
        self,
        attachment: F,
    ) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: ObjectMarker + Send + Sync,
        H: handlers::AttachmentHandler<A>;

    /// Converts the error into a local (non-thread-safe) [`Report`].
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is `Err`,
    /// converts the error into a [`Report`].
    ///
    /// See also [`into_report`](ResultExt::into_report) for a thread-safe version that returns a [`Report`]
    /// that can be sent across thread boundaries.
    ///
    /// # Examples
    ///
    /// ```
    /// # fn some_function() -> Result<String, MyError> { Ok(String::new()) }
    /// use rootcause::prelude::*;
    /// use std::{fmt, rc::Rc};
    ///
    /// // This error is neither Send nor Sync
    /// #[derive(Debug)]
    /// struct MyError(Rc<String>);
    /// impl fmt::Display for MyError {
    ///     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    ///         write!(f, "{}", self.0)
    ///     }
    /// }
    ///
    /// impl std::error::Error for MyError {}
    ///
    /// let result: Result<String, MyError> = some_function();
    /// let report_result: Result<String, Report<MyError, _, Local>> = result.local_into_report();
    /// ```
    #[track_caller]
    #[must_use]
    fn local_into_report(self) -> Result<V, Report<E::Context, E::Ownership, Local>>
    where
        E: IntoReport<Local>;

    /// Converts the error into a new local (non-thread-safe) [`Report`] using the provided context.
    /// The current error is set as a child of the new [`Report`].
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is `Err`,
    /// converts the error into a report collection and adds the provided context.
    /// The context becomes the primary error message, with the original error
    /// becoming part of the error chain.
    ///
    /// This method also works when the original error is a [`ReportCollection`], in which case all
    /// errors in that collection are set as children of the new [`Report`].
    ///
    /// See also [`context`](ResultExt::context) for a thread-safe version that returns a [`Report`]
    /// that can be sent across thread boundaries.
    ///
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// use rootcause::prelude::*;
    /// use std::rc::Rc;
    ///
    /// let result: Result<i32, &str> = Err("network error");
    /// let report_result = result.local_context(Rc::from("Failed to fetch user data"));
    /// ```
    #[track_caller]
    #[must_use]
    fn local_context<C>(self, context: C) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        C: ObjectMarker + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a new local (non-thread-safe) [`Report`] using context generated by the provided closure.
    /// The current error is set as a child of the new [`Report`].
    ///
    /// This is similar to [`local_context`](ResultExt::local_context), but the context is computed lazily using
    /// a closure. This can be useful when computing the context is expensive, as the
    /// closure will only be called if an error actually occurs.
    ///
    /// This method also works when the original error is a [`ReportCollection`], in which case all
    /// errors in that collection are set as children of the new [`Report`].
    ///
    /// See also [`context_lazy`](ResultExt::context_lazy) for a thread-safe version that returns a [`Report`]
    /// that can be sent across thread boundaries.
    ///
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// use rootcause::prelude::*;
    /// use std::rc::Rc;
    ///
    /// let result: Result<i32, &str> = Err("network error");
    /// let report_result = result.local_context_lazy(|| Rc::from("Failed at specific time"));
    /// ```
    #[track_caller]
    #[must_use]
    fn local_context_lazy<C, F>(self, context: F) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        F: FnOnce() -> C,
        C: ObjectMarker + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a new local (non-thread-safe) [`Report`] using the provided context.
    /// The current error is set as a child of the new [`Report`].
    ///
    /// This is similar to [`local_context`](ResultExt::local_context), but uses a custom [`ContextHandler`] to control
    /// how the context is formatted and displayed.
    ///
    /// This method also works when the original error is a [`ReportCollection`], in which case all
    /// errors in that collection are set as children of the new [`Report`].
    ///
    /// See also [`context_with_handler`](ResultExt::context_with_handler) for a thread-safe version that returns a [`Report`]
    /// that can be sent across thread boundaries.
    ///
    /// [`ContextHandler`]: handlers::ContextHandler
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// use rootcause::prelude::*;
    /// use std::rc::Rc;
    /// // Assuming you have a custom handler implementation
    /// // let result: Result<i32, &str> = Err("network error");
    /// // let report_result = result.local_context_with_handler::<_, MyHandler>(Rc::from("custom context"));
    /// ```
    #[track_caller]
    #[must_use]
    fn local_context_with_handler<H, C>(self, context: C) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        C: ObjectMarker,
        H: handlers::ContextHandler<C>;

    /// Converts the error into a new local (non-thread-safe) [`Report`] using context generated by the provided closure.
    /// The current error is set as a child of the new [`Report`].
    ///
    /// Combines the lazy evaluation of [`local_context_lazy`](ResultExt::local_context_lazy) with the custom
    /// handler capabilities of [`local_context_with_handler`](ResultExt::local_context_with_handler).
    ///
    /// This method also works when the original error is a [`ReportCollection`], in which case all
    /// errors in that collection are set as children of the new [`Report`].
    ///
    /// See also [`context_with_handler_lazy`](ResultExt::context_with_handler_lazy) for a thread-safe version that returns a [`Report`]
    /// that can be sent across thread boundaries.
    ///
    /// [`ReportCollection`]: crate::report_collection::ReportCollection
    ///
    /// # Examples
    ///
    /// ```
    /// use rootcause::prelude::*;
    /// use std::rc::Rc;
    /// // Assuming you have a custom handler implementation
    /// // let result: Result<i32, &str> = Err("network error");
    /// // let report_result = result.local_context_with_handler_lazy::<_, _, MyHandler>(|| Rc::from("expensive context"));
    /// ```
    #[track_caller]
    #[must_use]
    fn local_context_with_handler_lazy<H, C, F>(
        self,
        context: F,
    ) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        F: FnOnce() -> C,
        C: ObjectMarker,
        H: handlers::ContextHandler<C>;

    /// Converts the error into a local (non-thread-safe) [`Report`] and adds the provided attachment to the [`Report`].
    ///
    /// If the result is `Ok`, returns the value unchanged. If the result is `Err`,
    /// converts the error into a [`Report`] and attaches the provided data as an attachment.
    /// Attachments provide additional context without changing the primary error message.
    ///
    /// See also [`attach`](ResultExt::attach) for a thread-safe version that returns a [`Report`]
    /// that can be sent across thread boundaries.
    ///
    /// # Examples
    ///
    /// ```
    /// use rootcause::prelude::*;
    /// use std::rc::Rc;
    ///
    /// let result: Result<i32, &str> = Err("parsing failed");
    /// let report_result = result.local_attach(Rc::from("debug info"));
    /// assert!(report_result.is_err());
    /// ```
    #[track_caller]
    #[must_use]
    fn local_attach<A>(self, attachment: A) -> Result<V, Report<E::Context, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        A: ObjectMarker + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a local (non-thread-safe) [`Report`] and adds an attachment generated by the provided closure to the [`Report`].
    ///
    /// This is similar to [`local_attach`](ResultExt::local_attach), but the attachment is computed lazily using
    /// a closure. This can be useful when computing the attachment is expensive, as the
    /// closure will only be called if an error actually occurs.
    ///
    /// See also [`attach_lazy`](ResultExt::attach_lazy) for a thread-safe version that returns a [`Report`]
    /// that can be sent across thread boundaries.
    ///
    /// # Examples
    ///
    /// ```
    /// use rootcause::prelude::*;
    /// use std::rc::Rc;
    ///
    /// let result: Result<i32, &str> = Err("parsing failed");
    /// let report_result = result.local_attach_lazy(|| Rc::from("expensive debug info"));
    /// assert!(report_result.is_err());
    /// ```
    #[track_caller]
    #[must_use]
    fn local_attach_lazy<A, F>(
        self,
        attachment: F,
    ) -> Result<V, Report<E::Context, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: ObjectMarker + core::fmt::Display + core::fmt::Debug;

    /// Converts the error into a local (non-thread-safe) [`Report`] and adds the provided attachment to the [`Report`].
    ///
    /// This is similar to [`local_attach`](ResultExt::local_attach), but uses a custom [`AttachmentHandler`] to control
    /// how the attachment is formatted and displayed.
    ///
    /// See also [`attach_with_handler`](ResultExt::attach_with_handler) for a thread-safe version that returns a [`Report`]
    /// that can be sent across thread boundaries.
    ///
    /// [`AttachmentHandler`]: handlers::AttachmentHandler
    ///
    /// # Examples
    ///
    /// ```
    /// use rootcause::prelude::*;
    /// use std::rc::Rc;
    /// // Assuming you have a custom handler implementation
    /// // let result: Result<i32, &str> = Err("parsing failed");
    /// // let report_result = result.local_attach_with_handler::<_, MyHandler>(Rc::from("debug data"));
    /// ```
    #[track_caller]
    #[must_use]
    fn local_attach_with_handler<H, A>(
        self,
        attachment: A,
    ) -> Result<V, Report<E::Context, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        A: ObjectMarker,
        H: handlers::AttachmentHandler<A>;

    /// Converts the error into a local (non-thread-safe) [`Report`] and adds an attachment generated by the provided closure to the [`Report`].
    ///
    /// Combines the lazy evaluation of [`local_attach_lazy`](ResultExt::local_attach_lazy) with the custom
    /// handler capabilities of [`local_attach_with_handler`](ResultExt::local_attach_with_handler).
    ///
    /// See also [`attach_with_handler_lazy`](ResultExt::attach_with_handler_lazy) for a thread-safe version that returns a [`Report`]
    /// that can be sent across thread boundaries.
    ///
    /// # Examples
    ///
    /// ```
    /// use rootcause::prelude::*;
    /// use std::rc::Rc;
    /// // Assuming you have a custom handler implementation
    /// // let result: Result<i32, &str> = Err("parsing failed");
    /// // let report_result = result.local_attach_with_handler_lazy::<_, _, MyHandler>(|| Rc::from("expensive debug data"));
    /// ```
    #[track_caller]
    #[must_use]
    fn local_attach_with_handler_lazy<H, A, F>(
        self,
        attachment: F,
    ) -> Result<V, Report<E::Context, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: ObjectMarker,
        H: handlers::AttachmentHandler<A>;
}

impl<V, E> ResultExt<V, E> for Result<V, E> {
    #[inline(always)]
    fn into_report(self) -> Result<V, Report<E::Context, E::Ownership, SendSync>>
    where
        E: IntoReport<SendSync>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report()),
        }
    }

    #[inline(always)]
    fn context<C>(self, context: C) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        C: ObjectMarker + Send + Sync + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report_collection().context(context)),
        }
    }

    #[inline(always)]
    fn context_lazy<C, F>(self, context: F) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        F: FnOnce() -> C,
        C: ObjectMarker + Send + Sync + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report_collection().context(context())),
        }
    }

    #[inline(always)]
    fn context_with_handler<H, C>(self, context: C) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        C: ObjectMarker + Send + Sync,
        H: handlers::ContextHandler<C>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e
                .into_report_collection()
                .context_with_handler::<H, _>(context)),
        }
    }

    #[inline(always)]
    fn context_with_handler_lazy<H, C, F>(
        self,
        context: F,
    ) -> Result<V, Report<C, Mutable, SendSync>>
    where
        E: IntoReportCollection<SendSync>,
        F: FnOnce() -> C,
        C: ObjectMarker + Send + Sync,
        H: handlers::ContextHandler<C>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e
                .into_report_collection()
                .context_with_handler::<H, _>(context())),
        }
    }

    #[inline(always)]
    fn attach<A>(self, attachment: A) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        A: ObjectMarker + Send + Sync + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach(attachment)),
        }
    }

    #[inline(always)]
    fn attach_lazy<A, F>(self, attachment: F) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: ObjectMarker + Send + Sync + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach(attachment())),
        }
    }

    #[inline(always)]
    fn attach_with_handler<H, A>(
        self,
        attachment: A,
    ) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        A: ObjectMarker + Send + Sync,
        H: handlers::AttachmentHandler<A>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach_with_handler::<H, _>(attachment)),
        }
    }

    #[inline(always)]
    fn attach_with_handler_lazy<H, A, F>(
        self,
        attachment: F,
    ) -> Result<V, Report<E::Context, Mutable, SendSync>>
    where
        E: IntoReport<SendSync, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: ObjectMarker + Send + Sync,
        H: handlers::AttachmentHandler<A>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach_with_handler::<H, _>(attachment())),
        }
    }

    #[inline(always)]
    fn local_into_report(self) -> Result<V, Report<E::Context, E::Ownership, Local>>
    where
        E: IntoReport<Local>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report()),
        }
    }

    #[inline(always)]
    fn local_context<C>(self, context: C) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        C: ObjectMarker + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report_collection().context(context)),
        }
    }

    #[inline(always)]
    fn local_context_lazy<C, F>(self, context: F) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        F: FnOnce() -> C,
        C: ObjectMarker + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report_collection().context(context())),
        }
    }

    #[inline(always)]
    fn local_context_with_handler<H, C>(self, context: C) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        C: ObjectMarker,
        H: handlers::ContextHandler<C>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e
                .into_report_collection()
                .context_with_handler::<H, _>(context)),
        }
    }

    #[inline(always)]
    fn local_context_with_handler_lazy<H, C, F>(
        self,
        context: F,
    ) -> Result<V, Report<C, Mutable, Local>>
    where
        E: IntoReportCollection<Local>,
        F: FnOnce() -> C,
        C: ObjectMarker,
        H: handlers::ContextHandler<C>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e
                .into_report_collection()
                .context_with_handler::<H, _>(context())),
        }
    }

    #[inline(always)]
    fn local_attach<A>(self, attachment: A) -> Result<V, Report<<E>::Context, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        A: ObjectMarker + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach(attachment)),
        }
    }

    #[inline(always)]
    fn local_attach_lazy<A, F>(
        self,
        attachment: F,
    ) -> Result<V, Report<<E>::Context, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: ObjectMarker + core::fmt::Display + core::fmt::Debug,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach(attachment())),
        }
    }

    #[inline(always)]
    fn local_attach_with_handler<H, A>(
        self,
        attachment: A,
    ) -> Result<V, Report<<E>::Context, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        A: ObjectMarker,
        H: handlers::AttachmentHandler<A>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach_with_handler::<H, _>(attachment)),
        }
    }

    #[inline(always)]
    fn local_attach_with_handler_lazy<H, A, F>(
        self,
        attachment: F,
    ) -> Result<V, Report<<E>::Context, Mutable, Local>>
    where
        E: IntoReport<Local, Ownership = Mutable>,
        F: FnOnce() -> A,
        A: ObjectMarker,
        H: handlers::AttachmentHandler<A>,
    {
        match self {
            Ok(v) => Ok(v),
            Err(e) => Err(e.into_report().attach_with_handler::<H, _>(attachment())),
        }
    }
}
